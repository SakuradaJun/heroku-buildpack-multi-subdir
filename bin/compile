#!/usr/bin/env bash

set -e
set -x

function indent() {
  c='s/^/       /'
  case $(uname) in
    Darwin) sed -l "$c";;
    *)      sed -u "$c";;
  esac
}

unset GIT_DIR


##########################################

# The location of the pre-compiled libffi binary.
VENDORED_LIBFFI="https://s3-us-west-2.amazonaws.com/mfenniak-graphviz/libffi-3.0.tgz"
VENDORED_PATH=/app/vendor/libffi-3.0


echo "-----> Noticed cffi. Bootstrapping libffi."
PREV_DIR=$(pwd)
mkdir -p "$VENDORED_PATH"
cd "$VENDORED_PATH"

# Download and extract libffi into target vendor directory.
curl -s -L -o tmp-libffi.tar.gz $VENDORED_LIBFFI
tar -zxvf tmp-libffi.tar.gz > /dev/null
rm tmp-libffi.tar.gz

# Add libffi's to PKG_CONFIG_PATH
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$(pwd)/lib/pkgconfig/
echo "PKG_CONFIG_PATH=${PKG_CONFIG_PATH}"
if [ -e $(pwd)/lib/pkgconfig/libffi.pc ]
then
echo "libffi.pc is in-place at $(pwd)/vendor/lib/pkgconfig/libffi.pc, libffi-based builds should work!"
fi

cd "$PREV_DIR"
echo "-----> Root directory: $1"

##########################################


for BUILDPACK in $(cat $1/.buildpacks); do
  dir=$(mktemp -t buildpackXXXXX)
  rm -rf $dir

  subdir=""
  if [[ $BUILDPACK == *'='* ]]; then
    subdir="/"$(echo $BUILDPACK | cut -d"=" -f 1)
    BUILDPACK=$(echo $BUILDPACK | cut -d"=" -f 2)
  fi

  url=${BUILDPACK%#*}
  branch=${BUILDPACK#*#}

  if [ "$branch" == "$url" ]; then
    branch=""
  fi

  if [ "$url" != "" ]; then
    echo "=====> Downloading Buildpack: $url, branch: $branch, to tmp dir $dir, against source's subdir: $subdir"

    if [[ "$url" =~ \.tgz$ ]]; then
      mkdir -p "$dir"
      curl -s "$url" | tar xvz -C "$dir" >/dev/null 2>&1
    else
      git clone $url $dir >/dev/null 2>&1
      if [ -f "$dir/.gitmodules" ]; then
        echo "=====> Detected git submodules. Initializing..."
        (cd $dir && git submodule update --init --recursive)
      fi
    fi
    cd $dir

    if [ "$branch" != "" ]; then
      git checkout $branch >/dev/null 2>&1
    fi

    # we'll get errors later if these are needed and don't exist
    chmod -f +x $dir/bin/{detect,compile,release} || true

    framework=$($dir/bin/detect $1$subdir)

    if [ $? == 0 ]; then
      echo "=====> Detected Framework: $framework"
      $dir/bin/compile $1$subdir $2 $3

      if [ $? != 0 ]; then
        exit 1
      fi

      # check if the buildpack left behind an environment for subsequent ones
      if [ -e $dir/export ]; then
        source $dir/export
      fi

      if [ -x $dir/bin/release ]; then
        $dir/bin/release $1$subdir >> $1/last_pack_release.out
      fi
    fi
    cd $1
    mkdir -p .heroku
    if [[ -d $1$subdir/.heroku ]]; then
        rsync --recursive --copy-links -v $1$subdir/.heroku $1/
    fi
    find $1/.heroku
  fi
done

if [[ -e $1/last_pack_release.out ]]; then
  echo "Using release configuration from last framework ($framework)."
fi

echo "\$1=$1"
cd $1
ls -a $1

ls -la $1/backend
ls -la $1/backend/.heroku/python/bin/

ln -s $1/backend/.heroku /app/.heroku

export PATH=$1/backend/.heroku/python/bin/:$PATH
export PYTHONHOME=$1/backend/.heroku/python
export LIBRARY_PATH=$1/backend/.heroku/python/vendor/lib:$1/backend/.heroku/python/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=$1/backend/.heroku/python/vendor/lib:$1/backend/.heroku/python/lib:$LD_LIBRARY_PATH
export LANG=${LANG:-en_US.UTF-8}

python --version
which python

node --version
which node

ls -la /app

ls /app/.profile.d/
cat /app/Procfile

pip --version
pip install virtualenv
virtualenv --version
python ./install/install.py install:all
